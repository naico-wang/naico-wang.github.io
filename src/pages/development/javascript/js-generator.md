---
title: JavaScript迭代器
date: 2024-08-15
category: JavaScript/TypeScript
---

# JavaScript迭代器，助你更高效地处理异步编程

`JavaScript`这门编程语言，总是能带给人无尽的惊喜和探索的乐趣。今天，我想带大家一起深入了解其中一个非常有趣且强大的功能——生成器（`Generators`）。

生成器在 `JavaScript` 中可能一开始看起来有些神秘和复杂，但一旦你掌握了它们的工作原理和应用场景，就会发现它们的独特魅力和巨大潜力。生成器可以帮助你更高效地`处理异步编程`、`简化迭代操作`以及`优化代码性能`。

## 什么是生成器？

生成器是一种特殊的 `JavaScript` `函数`，它允许你在执行过程中暂停和恢复。

与普通函数从头到尾一次性执行不同，生成器可以在执行过程中将控制权交还给调用它的上下文，这样你就可以更精细地控制代码的执行流程。

我们来看一个简单的例子：

```javascript
function* simpleGenerator() {
  console.log("第一次执行");
  yield 1;
  console.log("第二次执行");
  yield 2;
  console.log("第三次执行");
}

const gen = simpleGenerator();

console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: undefined, done: true }
```

在这个例子中，`simpleGenerator` 并不是一次性执行完毕。相反，它会在每个 `yield` 语句处暂停，只有当你明确调用 `next()` 方法时才会继续执行。这种行为正是生成器的独特之处。

## 何时使用以及为何使用？

那么问题来了，“什么时候应该用 `Generator` 而不是 `Promise` 呢？”

这是个好问题！生成器在需要精细控制执行流程的场景中特别有用。以下是一些具体的使用场景：

### 1. 延迟迭代

生成器在创建延迟迭代器（即按需生成值的序列）方面非常出色。这在处理潜在的无限数据流或大数据集时尤为有用，因为一次性加载所有数据到内存中是不可行的。

想象一下，你正在开发一个需要分页显示数据的应用程序，而不是一次性加载所有数据。这时，生成器就派上用场了：

```javascript
function* loadPages() {
  let page = 1;
  while (page <= 3) { // 假设我们有3页数据
    console.log(`加载第${page}页的数据`);
    yield `第${page}页的数据`;
    page++;
  }
}

const pages = loadPages();

console.log(pages.next().value); // 加载第1页的数据
console.log(pages.next().value); // 加载第2页的数据
console.log(pages.next().value); // 加载第3页的数据
```

在这个例子中，`loadPages` 生成器按需加载每一页的数据，而不是一次性获取所有数据。这种方式节省了内存并提高了性能。

### 2. 自定义控制流

生成器提供了一种独特的方式来管理复杂的控制流，尤其是异步控制流。通过将生成器与 `Promise` 结合，你可以创建出看起来几乎是同步执行的代码，但实际上处理的是异步操作。

```javascript
function* asyncFlow() {
  const data = yield fetch('/api/data').then(res => res.json());
  console.log(data);
}

const iterator = asyncFlow();

iterator.next().value.then((data) => {
  iterator.next(data);
});
```

在这个例子中，生成器允许你“暂停”执行，直到 `fetch('/api/data')` 的 `Promise` 解析完成，然后再用获取的数据继续执行。这种方法在 `async/await` 成为标准之前特别流行，当你需要比 `async/await` 更细致的控制时，它仍然非常有用。

### 3. 状态机

状态机是复杂应用中的常见模式，生成器可以用来干净且简洁地实现它们。生成器在特定状态下 `yield` 的能力使得它们非常适合管理状态之间的转换。

假设你在开发一个订单处理系统，需要管理订单的不同状态，如“`处理中`”、“`已发货`”和“`已完成`”等。生成器可以帮你轻松实现这个过程：

```javascript
function* orderStateMachine() {
  while (true) {
    const state = yield;
    switch (state) {
      case "PROCESSING":
        console.log("订单处理中...");
        break;
      case "SHIPPED":
        console.log("订单已发货");
        break;
      case "COMPLETED":
        console.log("订单已完成");
        return;
    }
  }
}

const orderMachine = orderStateMachine();
orderMachine.next(); // 初始化生成器
orderMachine.next("PROCESSING"); // 订单处理中...
orderMachine.next("SHIPPED"); // 订单已发货
orderMachine.next("COMPLETED"); // 订单已完成
```

在这个例子中，生成器允许你在不同的状态下暂停执行，然后根据传入的状态进行相应的操作。这种方法提供了一种清晰、易维护的方式来处理订单流程中的各种状态。

## Generators vs Promises: 一决高下

那什么时候应该使用生成器而不是 `Promise` 呢？

### 生成器的优势

1. **精细化控制**
    
   生成器就像是你的遥控器，可以随时暂停和恢复函数的执行。这在一些需要按需处理的数据操作中非常有用。打个比方，想象你在看一部电影，可以随时按下暂停键，去做其他事情，回来后再继续播放。生成器就是这样的“暂停键”。

   比如，在开发一个分页加载数据的功能时，生成器可以帮助你逐页加载数据，而不是一次性加载所有数据，从而节省内存。

2. **内存效率**
    
   生成器按需生成值，非常节省内存。这对于处理大数据集或数据流特别有用。比如，你在处理一个大型的产品列表时，生成器可以让你每次只加载一部分产品，而不是一次性加载所有产品。

3. **可读的异步代码**
  
   尽管 `async/await` 已经成为处理异步操作的主流，生成器仍然提供了一种独特的可读性和控制力，使得复杂的异步流程更易于管理。比如在订单处理系统中，你可以使用生成器来控制订单的不同状态，让代码逻辑更加清晰和易维护。

### Promise 的优势

1. **简单和普及**

   `Promise` 是 `JavaScript` 的标准，使用起来非常简单，并且有丰富的库和工具支持。它就像是一部大家都在用的智能手机，功能强大且易于上手。

2. **并发处理**

   `Promise` 在处理多个异步操作时非常出色，比如同时进行多个 `API` 调用，就像你可以同时看电影、听音乐、和朋友聊天一样轻松。

3. **错误处理**

   使用 `async/await`，错误处理变得更加简单，可以用 `try/catch` 块轻松管理异步代码中的异常。这就像是你有一个万能的急救箱，可以随时处理突发状况。

### 什么时候用生成器？

如果你需要精细控制代码的执行顺序，处理大数据集，或者管理复杂的异步流程，生成器是一个很好的选择。它们提供了灵活性和效率，让你的代码更易维护。

### 什么时候用 Promise？

对于大多数的异步任务，特别是需要同时处理多个异步操作的场景，`Promise` 是更简单和直接的选择。它们已经成为 `JavaScript` 的标准，并且有大量的支持资源。

无论是生成器还是 `Promise`，它们各有千秋。根据具体的业务需求选择合适的工具，才能事半功倍！

## 2024年使用生成器的最佳实践

既然我们已经讨论了为什么以及何时使用生成器，接下来让我们深入了解在2024年如何有效地使用生成器的一些最佳实践。

### 1. 保持简洁

生成器可以增加代码的复杂性，所以要谨慎使用。如果一个任务可以用 `Promise` 或 `async/await` 简单处理，那么没有必要使用生成器。就像在日常生活中，有时简单的手工工具比复杂的电动工具更合适。

### 2. 结合 Promise 实现最大效果

生成器和 Promise 并不是互斥的。实际上，它们可以很好地互补。你可以用生成器来组织你的异步流程，用 Promise 来处理实际的异步操作。就像做一个复杂的项目时，生成器可以是你的计划表，而 Promise 是实际执行的步骤。

### 3. 注意迭代
 
使用生成器进行迭代时，一定要注意何时停止。如果不加以管理，生成器中的无限循环可能会成为一个大问题。确保你的生成器有明确的退出条件，就像你在跑步时，需要知道终点在哪里，否则会一直跑下去。

### 4. 彻底测试

由于生成器的独特执行流程，彻底测试非常关键。确保覆盖所有可能的执行路径，包括生成器可能意外 `yield` 或提前终止的边界情况。就像你在发布一个新应用程序之前，要确保它在各种情况下都能正常运行。

### 5. 利用 TypeScript 提供类型安全

既然你在使用 `TypeScript`，确保为你的生成器函数定义类型。这增加了一层安全性，帮助你在编译时捕捉潜在的问题。就像在建造房子时，使用正确的工具和材料可以确保结构的稳定性。

```javascript
function* typedGenerator(): Generator<number, void, unknown> {
  yield 1;
  yield 2;
  yield 3;
}
```

这个生成器依次生成数值 `1`、`2` 和 `3`，每次调用 `next()` 方法时，生成器会暂停并返回当前的数值。类型定义 `Generator<number, void, unknown>` 指定了生成器生成 `number` 类型的值，没有返回值 `(void)`，并且 `next` 方法接受 `unknown` 类型的参数。通过这种方式，可以在编译时捕捉到许多错误，增强代码的可读性和可靠性。

## 总结

生成器在2024年虽然不再是新鲜事物，但它们的魅力依旧不减。凭借对执行流程的精准控制和高效的内存利用，生成器仍然是每个开发者工具库中不可或缺的一部分。

尽管 `Promise` 和 `async/await` 有着广泛的应用，但生成器提供了一种独特的视角，可以简化复杂任务并优化性能。

小伙伴们，你们有没有在项目中使用过生成器呢？或者有什么有趣的生成器应用场景？在评论区分享你的经验和心得吧！如果你还没用过，不妨试试，或许会有意想不到的收获哦！
